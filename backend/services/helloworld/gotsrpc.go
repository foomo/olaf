// Code generated by gotsrpc https://github.com/foomo/gotsrpc  - DO NOT EDIT.

package helloworld

import (
	http "net/http"
	time "time"

	gotsrpc "github.com/foomo/gotsrpc"
)

type ServiceGoTSRPCProxy struct {
	EndPoint    string
	allowOrigin []string
	service     *Service
}

func NewDefaultServiceGoTSRPCProxy(service *Service, allowOrigin []string) *ServiceGoTSRPCProxy {
	return &ServiceGoTSRPCProxy{
		EndPoint:    "/services/helloworld",
		allowOrigin: allowOrigin,
		service:     service,
	}
}

func NewServiceGoTSRPCProxy(service *Service, endpoint string, allowOrigin []string) *ServiceGoTSRPCProxy {
	return &ServiceGoTSRPCProxy{
		EndPoint:    endpoint,
		allowOrigin: allowOrigin,
		service:     service,
	}
}

// ServeHTTP exposes your service
func (p *ServiceGoTSRPCProxy) ServeHTTP(w http.ResponseWriter, r *http.Request) {

	for _, origin := range p.allowOrigin {
		// todo we have to compare this with the referer ... and only send one
		w.Header().Add("Access-Control-Allow-Origin", origin)
	}
	w.Header().Set("Access-Control-Allow-Credentials", "true")
	if r.Method != http.MethodPost {
		if r.Method == http.MethodOptions {
			return
		}
		gotsrpc.ErrorMethodNotAllowed(w)
		return
	}

	var args []interface{}
	funcName := gotsrpc.GetCalledFunc(r, p.EndPoint)
	callStats := gotsrpc.GetStatsForRequest(r)
	if callStats != nil {
		callStats.Func = funcName
		callStats.Package = "github.com/foomo/olaf/backend/services/helloworld"
		callStats.Service = "Service"
	}
	switch funcName {
	case "HelloWorld":
		var (
			arg_name string
		)
		args = []interface{}{&arg_name}
		err := gotsrpc.LoadArgs(&args, callStats, r)
		if err != nil {
			gotsrpc.ErrorCouldNotLoadArgs(w)
			return
		}
		executionStart := time.Now()
		helloWorldRet := p.service.HelloWorld(arg_name)
		if callStats != nil {
			callStats.Execution = time.Now().Sub(executionStart)
		}
		gotsrpc.Reply([]interface{}{helloWorldRet}, callStats, r, w)
		return
	default:
		gotsrpc.ClearStats(r)
		http.Error(w, "404 - not found "+r.URL.Path, http.StatusNotFound)
	}
}

type AdminServiceGoTSRPCProxy struct {
	EndPoint    string
	allowOrigin []string
	service     *AdminService
}

func NewDefaultAdminServiceGoTSRPCProxy(service *AdminService, allowOrigin []string) *AdminServiceGoTSRPCProxy {
	return &AdminServiceGoTSRPCProxy{
		EndPoint:    "/services/helloworld-admin",
		allowOrigin: allowOrigin,
		service:     service,
	}
}

func NewAdminServiceGoTSRPCProxy(service *AdminService, endpoint string, allowOrigin []string) *AdminServiceGoTSRPCProxy {
	return &AdminServiceGoTSRPCProxy{
		EndPoint:    endpoint,
		allowOrigin: allowOrigin,
		service:     service,
	}
}

// ServeHTTP exposes your service
func (p *AdminServiceGoTSRPCProxy) ServeHTTP(w http.ResponseWriter, r *http.Request) {

	for _, origin := range p.allowOrigin {
		// todo we have to compare this with the referer ... and only send one
		w.Header().Add("Access-Control-Allow-Origin", origin)
	}
	w.Header().Set("Access-Control-Allow-Credentials", "true")
	if r.Method != http.MethodPost {
		if r.Method == http.MethodOptions {
			return
		}
		gotsrpc.ErrorMethodNotAllowed(w)
		return
	}

	funcName := gotsrpc.GetCalledFunc(r, p.EndPoint)
	callStats := gotsrpc.GetStatsForRequest(r)
	if callStats != nil {
		callStats.Func = funcName
		callStats.Package = "github.com/foomo/olaf/backend/services/helloworld"
		callStats.Service = "AdminService"
	}
	switch funcName {
	case "HelloAdmin":
		executionStart := time.Now()
		helloAdminRet := p.service.HelloAdmin()
		if callStats != nil {
			callStats.Execution = time.Now().Sub(executionStart)
		}
		gotsrpc.Reply([]interface{}{helloAdminRet}, callStats, r, w)
		return
	default:
		gotsrpc.ClearStats(r)
		http.Error(w, "404 - not found "+r.URL.Path, http.StatusNotFound)
	}
}
